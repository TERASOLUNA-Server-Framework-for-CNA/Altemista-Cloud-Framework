
:fragment:

////
	Note: this fragment uses the _ifndef_ conditional preprocessor directive
	to exclude advanced topics if _getting-started_ is defined
////

The performance module offers the possibilty of measure the performance of an application in a non-intrusive, configurable and extensible manner. With this module, by example, is it possible to determine at any stage of development which queries to the database are taking longer than expected.

By default, it allows both storage and logging of the measures. This way, the performance statistics can be exploited both inside and outside the application (e.g.: by creating a "health" page or using a log analysis tool). There are three predefined points for measuring:

Core performance feature::

At any layer, registering parameters and return values and measuring the method execution times.

JDBC performance::

When using a relational database through a datasource, registering the queries executed and the size of their result sets, and measuring the execution times.

Web performance::

At the web layer, measuring the time taken to perform each request to the application.

The interface `MeasuresStorage` defines storage policites for registering the measured tasks. It also allows retrieving the registered executions and clearing the container.

To actually use this feature, some <<altemista-cloudfwk-app-performance-conf-configuration,configuration>> is required to populate the container defined by the storage policies. Once this configuration is done, there are two ways of exploit the statistics generated by the module:

* <<altemista-cloudfwk-app-performance-conf-overview-exploiting,Programatically>> (e.g.: by creating an statistics page inside the application).

* By <<altemista-cloudfwk-app-performance-conf-overview-logging,logging those statistics>> to be exploited externally (e.g.: with a log analysis software, which is out of the scope of this document).

The framework already provides out-of-the-box support for the programatic way, using storage policies for keeping the longest measured tasks. However, when the performance feature is installed with the plug-in, logging will be set up in the application configuration with the default patterns:

[source,options="nowrap"]
----
START EXECUTION TRACE:
Operation started on: sun, 01 jan 2017 01:02:03.4567 GMT
	67ms	|----> public abstract String com.mycompany.application.module.service.ExampleService.example(String,int) ("foo", 1) returned "foo FOO"
	32ms		|----> public abstract String com.mycompany.application.module.service.AnotherExampleService.example(String) ("foo") returned "foo FOO"
END EXECUTION TRACE
----

[[altemista-cloudfwk-app-performance-conf-overview-exploiting]]
== Exploiting statistics

To expose the statistics to the application, autowire the storage policies to the proper service or controller. If more than one performance module is used by the application (e.g.: both method execution and JDBC modules have been added), use the proper `@Qualifier` annotation:

[source]
----
@Autowired
@Qualifier("methodExecutionMeasuresStorage")
private MeasuresStorage methodExecutionMeasuresStorage;

@Autowired
@Qualifier("jdbcMeasuresStorage")
private MeasuresStorage jdbcMeasuresStorage;

@Autowired
@Qualifier("webMeasuresStorage")
private MeasuresStorage webMeasuresStorage;
----

For example, it is possible to create an scheduled task that sends a daily email with the executions that took longer than 1 minute and then clears the storage; simply inject the proper `MeasuresStorage` bean where needed.

[[altemista-cloudfwk-app-performance-conf-overview-logging]]
== Logging statistics

It is usual for applications to want the performance data being logged as the application is running. This can be achieved by overriding the <<altemista-cloudfwk-app-performance-conf-internals-core,default storage policy>> as shown:

[source,xml]
.spring/new-application-performance.xml
----
include::{basedir}/altemista-cloudfwk-app-performance-conf/src/test/resources/spring/altemista-cloudfwk-example-performance.xml[tags=methodExecutionWithLog]
----
<1> The `LogMeasuresStorageWrapperImpl` class is provided by the framework. It logs the measures when they are being added to the actual storage.
<2> To keep an storage policy registering the longest executions, nest it in the `target` property. If the application just wants to log the measures and does not require to store them, leave empty the `target` property.
<3> The actual logger and the patterns that `LogMeasuresStorageWrapperImpl` uses to print the measured tasks are fully configurable. See the Javadoc of the class for further details.

IMPORTANT: If the default storage policies have been replaced by implementations that does not store information (e.g: `LogMeasuresStorageWrapperImpl` without wrapped implementation), the storages will be always empty.

ifndef::getting-started[]
== Performance statistics and confidential values

Depending on the configuration, the method execution performance aspect uses either `ToStringUtil` or `ReflectionToStringUtil` to obtain string representations of objects. This can lead to confidential values, such as passwords, being printed in logs or statistics reports, even if the `toString()` of the specific objects does not include that information.

The `@HiddenValue` annotation can be used to prevent this confidential values for being printed, using a placeholder instead. This annotation can annotate:

* A class to prevent any instance of that class for being printed (e.g.: a `CreditCard` class).

* A field to prevent a field of a class for being printed, without affecting the rest of the fields of that class (e.g.: the `password` field inside a class).

* A method argument to prevent that particular argument for being printed (e.g.: a `String password` argument).

* A method to prevent the return value of that method for being printed (e.g.: a `getPassword()` method).

IMPORTANT: Always use the `@HiddenValue` annotation on classes, fields, attributes or methods to prevent confidential for being printed.
endif::getting-started[]

ifndef::getting-started[]
== Performance statistics and JSON

Some `TaskInfo` implementations, such as `JdbcTaskInfo` can contain non-serializable values as they store the actual objects received or returned by the intercepted methods. This implementations keep not just the description, but also specific information because it may be needed by the application. The JSON view `MeasuredTask.View` allows the performance statistics to be exposed in a REST API:

[source]
----
@RestController
public class MethodExecutionMeasures {

	// ...

	@JsonView(MeasuredTask.View.class)
	@RequestMapping("/methodExecutionMeasuresStorage/get")
	public List<MeasuredTask> get() {
		
		return this.methodExecutionMeasuresStorage.get();
	}
}
----

CAUTION: Always use the view `MeasuredTask.View` to return `MeasuredTask` objects as JSON objects. 
endif::getting-started[]
